# 经典十大排序算法

### 术语解释：
- 时间复杂度
- 空间复杂度
- 稳定与不稳定算法

### 比较难理解的算法
- 归并排序
- 堆排序


### 1.冒泡排序


### 2.选择排序
- 算法步骤：
- 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
- 再从剩余未排序序列元素中继续寻找最小（大）元素，存放到已排序序列的末尾。
- 重复第二步，直到所有元素均排序完毕。

### 3.插入排序
- 算法步骤：
- 1.将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列
- 2.从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面）

### 4.希尔排序
- 希尔排序介绍：
- 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本，但希尔排序是非稳定排序算法。
- 希尔排序的基本思想是：先将整个待排序的记录序列分割成若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。

- 算法步骤：
- 选择一个增量序列t1,t2,...,tk, 其中ti>tj,tk=1;
- 按增量序列个数k，对序列进行k趟排序；
- 每趟排序，根据对应的增量ti，将待排序分割成若干长度未m的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。

### 5.归并排序
- 算法步骤：
- 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
- 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
- 比较两个指针所指向的元素，选择相对小的元素放入合并空间，并移动指针到下一个位置；
- 重复上一步直到某一指针达到序列尾部；
- 将另一序列剩下的所有元素直接复制到合并序列尾部。


### 6.快速排序
- 算法步骤：
- 从数列中跳出一个元素，称为“基准”（pivot）
- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆放在基准的后面（相同的数可以放到任意一边）。在这个分区退出之和，该基准就处于数列的中间位置。
- 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序

### 7.堆排序
- 堆排序介绍：
- 堆排序是指利用堆这种数据结构所设计的一种排序算法。

- 算法步骤：
- 将待排序序列构建成一个堆H[0...n-1],根据（升序降序需求）选择大项堆或小项堆；
- 把堆首（最大值）和堆尾互换
- 把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置
- 重复步骤2，直到堆的尺寸为1

### 8.计数排序
- 计数排序介绍：
- 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

- 算法步骤：
- 找出待排序列表中最大和最小的元素
- 构建中间列表，元素全为0，长度为最大值与最小值之间的差值加1
- 统计待排序列表中每个值i出现的次数，并将中间列表中下标为i-min的值加一
- 将中间列表中非零值的下标反转回原有元素i（即加上最小值），构建最终有序列表

### 9.桶排序
- 桶排序介绍：
- 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，需要做到这两点：1.在额外空间充足的情况下，尽量增大桶的数量。2.使用的映射函数能够将输入的N个数据均匀的分配到K个桶中。

- 算法步骤：
- 设置固定数量的空桶
- 把数据放到对应的桶中
- 对每个不为空的桶中数据进行排序
- 拼接不为空的桶中数据得到结果

### 10.基数排序
- 基数排序介绍
- 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别进行比较。
- 算法步骤:
- 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补0
- 从最低位开始，依次进行一次排序
- 从最低位排序一值到最到位排序完成以后，数列就变成一个有序序列。

### 资料参考：
https://github.com/hustcc/JS-Sorting-Algorithm  

